@page "/matrix-receiver-server"
@attribute [StreamRendering]
@rendermode InteractiveServer
@using System.Text.Json
@using Microsoft.AspNetCore.SignalR.Client
@implements IAsyncDisposable
@inject IConfiguration Configuration


<PageTitle>Live view Server</PageTitle>


<div style="display: flex; justify-content: space-between;">
    <h5>Hub Connection Status</h5>
    @if (IsConnected)
    {
        <p style="color: green;">Connected</p>
    }
    else
    {
        <p style="color: red;">Disconnected</p>
    }
</div>

@if (_avgDistance == null)
{
    <p><em>Waiting for data ...</em></p>
}
else
{
    <div style="display: flex; justify-content: space-between;">
        <h5>Average Distance</h5>
        <p>@_avgDistance mm</p>
        <h5>User</h5>
        <p>@_hubUser</p>
    </div>

    <div style="flex: 1;">
        <div class="depth-image" style="width: 640px; height: 640px; display: grid; grid-template-columns: repeat(32, 1fr); gap: 0;">
            @if (_dataFrame != null)
            {
                int res = 32;
                for (int i = 0; i < res; i++)
                {
                    for (int j = 0; j < res; j++)
                    {
                        int index = i * res + j;
                        var value = _dataFrame[index];
                        var color = GetColorFromValue(value);
                        <div class="pixel" style="background-color: @color; width: 20px; height: 20px; margin 0; padding: 0;"></div>
                    }
                }
            }
            else
            {
                <p>No data received yet.</p>
            }
        </div>
    </div>
}


@code {
    private HubConnection? _hubConnection;
    private ushort[]? _dataFrame;
    private ushort? _avgDistance;
    private string? _hubUser;

    protected override async Task OnInitializedAsync()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(@Configuration["Api:HubURL"]) 
            .Build();

        _hubConnection.On<string, ushort[], ushort>("ReceiveMatrix", (user, jsonMatrix, avgDistanceValue) =>
        {
            _dataFrame = jsonMatrix;
            _avgDistance = avgDistanceValue;
            _hubUser = user;

            InvokeAsync(StateHasChanged);
        });

        await _hubConnection.StartAsync();
    }

    public bool IsConnected =>
        _hubConnection?.State == HubConnectionState.Connected;

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.DisposeAsync();
        }
    }

    private string GetColorFromValue(ushort value)
    {
        // Załóżmy, że maksymalna wartość to 4000
        double ratio = Math.Clamp(value / (double)4000, 0, 1);
        int scaledRatio = (int)(ratio * 255);

        int r, g, b;

        if (ratio <= 0.25)
        {
            // Pierwsza ćwiartka: od czerwonego do żółtego
            r = 255;
            g = scaledRatio * 4; // Zwiększanie zielonego
            b = 0;
        }
        else if (ratio <= 0.5)
        {
            // Druga ćwiartka: od żółtego do zielonego
            r = 255 - ((scaledRatio - 64) * 4); // Redukcja czerwonego
            g = 255; // Zielony jest maksymalny
            b = 0;
        }
        else if (ratio <= 0.75)
        {
            // Trzecia ćwiartka: od zielonego do niebieskiego
            r = 0; // Czerwony jest minimalny
            g = 255 - ((scaledRatio - 128) * 4); // Redukcja zielonego
            b = (scaledRatio - 128) * 4; // Zwiększanie niebieskiego
        }
        else
        {
            // Czwarta ćwiartka: od niebieskiego do fioletowego
            r = (scaledRatio - 192) * 4; // Zwiększanie czerwonego
            g = 0; // Zielony jest minimalny
            b = 255; // Niebieski jest maksymalny
        }

        return $"rgb({Math.Clamp(r, 0, 255)}, {Math.Clamp(g, 0, 255)}, {Math.Clamp(b, 0, 255)})";
    }



}
