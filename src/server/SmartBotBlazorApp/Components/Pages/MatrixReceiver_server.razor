@page "/matrix-receiver-server"
@rendermode InteractiveServer
@implements IAsyncDisposable
@inject NavigationManager Navigation
@attribute [Authorize]
@using RobotMovementInput


<PageTitle>Live View Matrix</PageTitle>

<div style="display: flex; justify-content: center; max-width: 1000px; margin: 0 auto; padding: 20px;">
    <!-- Depth Image on the Left Side -->
    <table @ref="_keyobardInputHandler.keyboardInputRef" tabindex="0" @onkeydown="HandleKeyDown" @onkeyup=stopInputToRobot>
        <div style="flex: 1; max-width: 700px; margin-right: 20px;">
            <div class="depth-image"
                 style="width: 512px; height: 512px; display: grid; grid-template-columns: repeat(32, 1fr); gap: 0px;">
                @if (_dataFrame == null)
                {
                    <div class=" justify-content-center align-items-center">
                        <img src="@_testImage" alt="Test Image" width="512" height="512"/>
                        <div class="spinner-border" role="status"/>
                    </div>
                }
                else if (IsConnected)
                {
                    int res = 32;
                    for (int i = 0; i < res; i++)
                    {
                        for (int j = 0; j < res; j++)
                        {
                            int index = i * res + j;
                            var value = _dataFrame[index];
                            var color = GetColorFromValue(value);
                            <div class="pixel" style="background-color: @color; width: 100%; height: 100%; margin 0; padding: 0;"></div>
                        }
                    }

                }
            </div>
            <!-- TODO: układ strony sie rozwala?-->
            @if (_dataFrame != null)
            {
                <thead>
                <tr>
                    <th>
                        Pressed Key
                    </th>
                    <th>
                        Counter
                    </th>
                    <th>
                        <div class="joystick-container">
                            <!-- Joystick Section -->
                            <div id="joystickContainer" @onpointerdown="OnPointerDown" @onpointermove="OnPointerMove" @onpointerup="OnPointerUp" @onpointercancel="OnPointerUp">
                                <div id="joystickKnob" style="left: @(_joystickHandler.KnobPosX - 25)px; top: @(_joystickHandler.KnobPosY - @joystickRadius)px;"></div>
                            </div>
                        </div>
                    </th>
                    <th>
                        Joystick Counter
                    </th>
                    <th>
                        LE Value
                    </th>
                    <th>
                        RE Value
                    </th>
                    <th>
                        StopRobot
                    </th>
                </tr>

                </thead>

                <tbody>
                <tr>
                    <td>
                        @_keyobardInputHandler.pressedKey
                    </td>
                    <td>
                        @_keyobardInputHandler.counter

                    </td>
                    <td>@_joystickHandler.joystickDirection</td>
                    <td>@_joystickHandler.Counter</td>
                    <td>@_LeftEngineValue</td>
                    <td>@_RightEngineValue</td>
                    <td>@_didIStoppedRobot</td>
                </tr>
                </tbody>
            }

            </div>
        </table>


<!-- Info Section on the Right Side -->
<div style="flex: 1; display: flex; flex-direction: column; gap: 20px;min-width: 500px;">
    <!-- Connection Status Section -->
    <div style="display: flex; flex-wrap: wrap; gap: 20px; padding: 10px; background-color: #f5f5f5; border-radius: 8px;">
        <h5>Hub Connection Status</h5>
            @if (IsConnected)
            {
            <p style="color: green; font-weight: bold;">Connected</p>
            }
            else
            {
            <p style="color: red; font-weight: bold;">Disconnected</p>
            }
    </div>

    <!-- Data Status Section -->
        @if (_avgDistance == null || _measurements == null || _hubUser == null)
        {
        <p><em>Waiting for data</em></p>
        <div class="d-flex justify-content-center">
            <div class="spinner-border" role="status"/>
        </div>
        }
        else
        {
        <div style="display: flex; flex-direction: column; gap: 10px;">
            <!-- User and Average Distance Section -->
            <div style="display: flex; flex-wrap: wrap; gap: 20px; padding: 10px; background-color: #f5f5f5; border-radius: 8px;">
                <div style="flex: 1; min-width: 100px;">
                    <h5>User</h5>
                    <p>@_hubUser</p>
                </div>
                <div style="flex: 1; min-width: 100px;">
                    <h5>Average Distance</h5>
                    <p>@_avgDistance mm</p>
                </div>
            </div>

            <!-- Acceleration and Rotation Section -->
            <div style="display: flex; flex-wrap: wrap; gap: 20px; padding: 10px; background-color: #e9e9e9; border-radius: 8px;">
                <div style="flex: 1; min-width: 100px;">
                    <h5>Acceleration X</h5>
                    <p>@_measurements[0]</p>
                </div>
                <div style="flex: 1; min-width: 100px;">
                    <h5>Acceleration Y</h5>
                    <p>@_measurements[1]</p>
                </div>
                <div style="flex: 1; min-width: 100px;">
                    <h5>Acceleration Z</h5>
                    <p>@_measurements[2]</p>
                </div>
                <div style="flex: 1; min-width: 100px;">
                    <h5>Rotation X</h5>
                    <p>@_measurements[3]</p>
                </div>
                <div style="flex: 1; min-width: 100px;">
                    <h5>Rotation Y</h5>
                    <p>@_measurements[4]</p>
                </div>
                <div style="flex: 1; min-width: 100px;">
                    <h5>Rotation Z</h5>
                    <p>@_measurements[5]</p>
                </div>
                <div style="flex: 1; min-width: 100px;">
                    <h5>Temperature</h5>
                    <p>@_measurements[6] C</p>
                </div>
            </div>
        </div>
        }
</div>

<!-- Half-Circle Speedometer Section -->
    @if (!IsConnected)
    {
    <p><em>Waiting for data</em></p>
    <div class="spinner-border" role="status" />
    }
    else
    {
    <div style="display: flex; flex-direction: column; align-items: center; margin-top: 20px; margin-left: 20px">
        <h5>Speedometer</h5>
        <div style="position: relative; width: 200px; height: 100px; border-top-left-radius: 200px; border-top-right-radius: 200px; background: #e0e0e0; border: 5px solid #333; overflow: hidden;">
            <!-- Speedometer Needle -->
            <div style="position: absolute; width: 4px; height: 90px; background: red; bottom: 0; left: 50%; transform-origin: bottom; transform: rotate(@_speedometerAngle); transition: transform 0.3s ease;">
            </div>

            <!-- Speed Labels -->
            <div style="position: absolute; width: 100%; height: 100%; top: 0; display: flex; justify-content: space-between; align-items: flex-end; padding: 0 10px;">
                <span style="font-size: 12px; font-weight: bold;">0</span>
                <span style="font-size: 12px; font-weight: bold;">90</span>
                <span style="font-size: 12px; font-weight: bold;">180</span>
            </div>
        </div>
        <div style="margin-top: 10px; font-size: 16px; font-weight: bold;">
                @_currentSpeed km/h
        </div>
    </div>
    }
<!-- Half-Circle Speedometer Section -->


</div>



@code {
    //--------------------------------------------
    // Speedometer
    //mMaxSpeed mozna zmienic, na makysymalna predkosc po jakiej chcemy zeby wskazowka sie odchylial w prawo
    private static float mMaxSpeed = 180.0f;

    private int _currentSpeed = 0;
    private string _speedometerAngle = "-90deg"; // Needle angle (initial position)

    private void UpdateSpeed(int speed)
    {
        _currentSpeed = speed;
        double newAngle = -90 + (_currentSpeed / 180.0) * 180.0 ;
        // Map speed (0-180) to angle (-90 to 90 degrees)
        if (newAngle > 90)
        {
            newAngle = 90;
        }
        _speedometerAngle = $"{newAngle}deg";

        StateHasChanged();
    }

//Debug Function
    private async Task SimulateSpeedUpdate()
    {
        Random rand = new Random();
        while (true)
        {
            int newSpeed = rand.Next(0, 181); 
            UpdateSpeed(newSpeed);
            await Task.Delay(1000); // Update every second
        }
    }

    //--------------------------------------------------------------
    private static int joystickCenterX = 50;
    private static int joystickCenterY = 50;
    private static int joystickRadius = 25;
    private readonly string _testImage = debugFunctions.GetExampleImage();

    private JoystickInputHandler _joystickHandler = new JoystickInputHandler(joystickCenterX, joystickCenterY, joystickRadius);
    private CancellationTokenSource? _joystickCancellationTokenSource;

    private HubConnection? _hubConnection;
    private ushort[]? _dataFrame;
    private ushort? _avgDistance;
    private string? _hubUser;
    private double[]? _measurements;
    private int _LeftEngineValue = 0;
    private int _RightEngineValue = 0;

    private keyboardInputHandler _keyobardInputHandler = new keyboardInputHandler();
    private ROBOT_DIRECITON previousDir = ROBOT_DIRECITON.STOP;

    //Throttle

    private static DateTime _lastSaveTimeRobotInput = DateTime.MinValue;
    private static readonly TimeSpan ThrottleDurationSendRobotInput = TimeSpan.FromSeconds(0.250f);
    //-----------------


    //sybkihack, kiedys sie to napisze ladniej
    private bool _didIStoppedRobot = false;

    private async Task StartJoystickMessageLoop()
    {
        _joystickCancellationTokenSource?.Cancel();
        _joystickCancellationTokenSource = new CancellationTokenSource();
        var token = _joystickCancellationTokenSource.Token;

        try
        {
            while (!token.IsCancellationRequested)
            {
                if (_joystickHandler.validInput)
                {
                    sendInputToRobot(_joystickHandler.GetRobotEngineValues());
                    _joystickHandler.increaseCounter();
                }

                await InvokeAsync(StateHasChanged);
                await Task.Delay(10, token);
            }
        }
        catch (TaskCanceledException)
        {
            _joystickHandler.resetCounter();
        }
    }

    private void StopJoystickMessageLoop()
    {
        _joystickCancellationTokenSource?.Cancel();
    }

    private void OnPointerDown(PointerEventArgs e)
    {
        _joystickHandler.OnPointerDown(e.ClientX, e.ClientY);

        _ = StartJoystickMessageLoop();
    }

    private void OnPointerMove(PointerEventArgs e)
    {
        _joystickHandler.OnPointerMove(e.ClientX, e.ClientY);
        _LeftEngineValue = _joystickHandler.GetRobotEngineValues().Item1;
        _RightEngineValue = _joystickHandler.GetRobotEngineValues().Item2;
    }

    private void OnPointerUp(PointerEventArgs e)
    {
        _joystickHandler.OnPointerUp();
        // await stopInputToRobot();
        stopInputToRobot();
        StopJoystickMessageLoop();
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {

        _keyobardInputHandler.onKeyDown(e);
        _keyobardInputHandler.amIResetingCounter(previousDir != _keyobardInputHandler.robotDir);
        previousDir = _keyobardInputHandler.robotDir;

        _LeftEngineValue = _keyobardInputHandler.GetRobotEngineValues().Item1;
        _RightEngineValue = _keyobardInputHandler.GetRobotEngineValues().Item2;

        if (_keyobardInputHandler.validInput)
        {
            sendInputToRobot(_keyobardInputHandler.GetRobotEngineValues());
        }
    }




    private async void sendInputToRobot((int, int) engineValues)
    {

        if (_hubConnection is not null)
        {
            var currentTime = DateTime.Now;

            if ((currentTime - _lastSaveTimeRobotInput) <= ThrottleDurationSendRobotInput)
            {
                return;
            }
            _didIStoppedRobot = false;
            _lastSaveTimeRobotInput = currentTime;
            await _hubConnection.SendAsync("SendMovementCommand", "API", engineValues.Item1, engineValues.Item2);
        }
    }


    //szybki hack, kiedys sie zrobi ladniej
    // private async Task stopInputToRobot()
    private async void stopInputToRobot()
    {
        _LeftEngineValue = 0;
        _RightEngineValue = 0;
        // _didIStoppedRobot = true;

        if (_hubConnection is not null)
        {
            var currentTime = DateTime.Now;
            _lastSaveTimeRobotInput = currentTime;

            _didIStoppedRobot = true;
            await _hubConnection.SendAsync("SendMovementCommand", "API", 0, 0);
        }
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await _keyobardInputHandler.keyboardInputRef.FocusAsync();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        //------------------------------------------------------------------------------------------------
        //Speedometer
        await base.OnInitializedAsync();
        _ = SimulateSpeedUpdate(); // Start simulating speed updates

        //---------------------------------------DEBUG------------------------------------------------------------
        _measurements = debugFunctions.GenerateTestMeasurements(2);
        _dataFrame = debugFunctions.GenerateTestDataAscend(32);
        _avgDistance = debugFunctions.TestDistance;
        _hubUser = debugFunctions.TestUser;

        //--------------------------------------------------------------------------------------------------------

        _hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/signalhub"))
            .Build();

        _hubConnection.On<string, double[], ushort[], ushort>("ReceiveMatrix", (user, measurements, interpolatedMatrix, avgDistance) =>
        {
            _hubUser = user;
            _measurements = measurements;
            _dataFrame = interpolatedMatrix;
            _avgDistance = avgDistance;

            InvokeAsync(StateHasChanged);
        });

        await _hubConnection.StartAsync();

    }

    public bool IsConnected =>
        _hubConnection?.State == HubConnectionState.Connected;

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.DisposeAsync();
        }
    }

    private string GetColorFromValue(ushort value)
    {
        double ratio = Math.Clamp(value / (double)4000, 0, 1);
        int scaledRatio = (int)(ratio * 255);

        int r, g, b;

        if (ratio <= 0.25)
        {
            r = 255;
            g = scaledRatio * 4;
            b = 0;
        }
        else if (ratio <= 0.5)
        {
            r = 255 - ((scaledRatio - 64) * 4); 
            g = 255;
            b = 0;
        }
        else if (ratio <= 0.75)
        {
            r = 0; 
            g = 255 - ((scaledRatio - 128) * 4);
            b = (scaledRatio - 128) * 4;
        }
        else
        {
            r = (scaledRatio - 192) * 4;
            g = 0; 
            b = 255; 
        }

        return $"rgb({Math.Clamp(r, 0, 255)}, {Math.Clamp(g, 0, 255)}, {Math.Clamp(b, 0, 255)})";
    }
}
