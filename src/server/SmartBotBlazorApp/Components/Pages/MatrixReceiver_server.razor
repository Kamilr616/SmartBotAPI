@page "/matrix-receiver-server"
@rendermode InteractiveServer
@implements IAsyncDisposable
@inject NavigationManager Navigation

@using System.Text.Json
@using RobotMovementInput

<PageTitle>Live View Server</PageTitle>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<link rel="stylesheet" href="css/styles.css">

<div style="display: flex; justify-content: center; max-width: 1000px; margin: 0 auto; padding: 20px;">
    <!-- Left Panel: Depth Image and Keyboard Inputs -->
    <div>
        <!-- Depth Image -->
         <table @ref="_keyobardInputHandler.keyboardInputRef" tabindex="0" @onkeydown="HandleKeyDown">
        <div class="depth-image">
            @if (_dataFrame == null)
            {
                <div class="justify-content-center align-items-center">
                    <p><em>Waiting for image...</em></p>
                    <div class="spinner-border" role="status">
                        <span class="sr-only">Loading...</span>
                    </div>
                </div>
            }
            else
            {
                int res = 32;
                for (int i = 0; i < res; i++)
                {
                    for (int j = 0; j < res; j++)
                    {
                        int index = i * res + j;
                        var value = _dataFrame[index];
                        var color = GetColorFromValue(value);
                        <div class="pixel" style="background-color: @color;"></div>
                    }
                }
            }
        </div>

        </table>


        <!-- Keyboard Inputs -->
        <table @ref="_keyobardInputHandler.keyboardInputRef" tabindex="0" @onkeydown="HandleKeyDown">
            @if (_dataFrame != null)
            {
                <thead>
                    <tr>
                        <th>Pressed Key</th>
                        <th>Counter</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>@_keyobardInputHandler.pressedKey</td>
                        <td>@_keyobardInputHandler.counter</td>
                    </tr>
                </tbody>
            }
        </table>
    </div>

    <!-- Right Panel: Connection and Data Info -->
    <div class="right-panel">
        <!-- Connection Status -->
        <div class="connection-status">
            <h5>Hub Connection Status</h5>
            @if (IsConnected)
            {
                <p class="green">Connected</p>
            }
            else
            {
                <p class="red">Disconnected</p>
            }
        </div>

        <!-- Data Info -->
        @if (_avgDistance == null || _measurements == null || _hubUser == null)
        {
            <div class="d-flex justify-content-center">
                <p><em>Waiting for data...</em></p>
                <div class="spinner-border" role="status">
                    <span class="sr-only">Loading...</span>
                </div>
            </div>
        }
        else
        {
            <div class="data-status">
                <!-- User Info -->
                <div class="user-info">
                    <h5>User</h5>
                    <p>@_hubUser</p>
                </div>
                <!-- Average Distance -->
                <div class="average-distance">
                    <h5>Average Distance</h5>
                    <p>@_avgDistance mm</p>
                </div>
            </div>

            <!-- Measurement Details -->
            <div class="grid-container">
                <div>
                    <h5>Acceleration X</h5>
                    <p>@_measurements[0]</p>
                </div>
                <div>
                    <h5>Acceleration Y</h5>
                    <p>@_measurements[1]</p>
                </div>
                <div>
                    <h5>Acceleration Z</h5>
                    <p>@_measurements[2]</p>
                </div>
                <div>
                    <h5>Rotation X</h5>
                    <p>@_measurements[3]</p>
                </div>
                <div>
                    <h5>Rotation Y</h5>
                    <p>@_measurements[4]</p>
                </div>
                <div>
                    <h5>Rotation Z</h5>
                    <p>@_measurements[5]</p>
                </div>
                <div>
                    <h5>Temperature</h5>
                    <p>@_measurements[6] C</p>
                </div>
            </div>
        }
    </div>
</div>


@code {
    //hub connection
    private HubConnection? _hubConnection;
    private ushort[]? _dataFrame;
    private ushort? _avgDistance;
    private string? _hubUser;
    private double[]? _measurements;

    //keyboardInputs
    private keyboardInputHandler _keyobardInputHandler = new keyboardInputHandler();
    private ROBOT_DIRECITON previousDir = ROBOT_DIRECITON.STOP;



    private void HandleKeyDown(KeyboardEventArgs e)
    {

        _keyobardInputHandler.onKeyDown(e);
        _keyobardInputHandler.amIResetingCounter(previousDir != _keyobardInputHandler.robotDir);
        previousDir = _keyobardInputHandler.robotDir;


        if (_keyobardInputHandler.validInput)
        {
            sendInputToRobot(new RobotCommand(_keyobardInputHandler.robotDir).toJson());
        }
    }


    private void sendInputToRobot(string jsonCommand)
    {
        //tutaj wydmuszka, funkcja dostaje jsona z komenda ktora trzeba wyslac robotowi
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await _keyobardInputHandler.keyboardInputRef.FocusAsync();
        }
    }


    protected override async Task OnInitializedAsync()
    {

        //------------------------------------------------------------
        _dataFrame = GenerateTestDataAscend(32);
        _avgDistance = null;
        _hubUser = "TEST_DATA";


        await Task.CompletedTask;

        //-------------------------------------------------------------

        _hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/signalhub"))
            .Build();

        _hubConnection.On<string, double[], ushort[], ushort>("ReceiveMatrix", (user, measurements, interpolatedMatrix, avgDistance) =>
        {
            _hubUser = user;
            _measurements = measurements;
            _dataFrame = interpolatedMatrix;
            _avgDistance = avgDistance;

            InvokeAsync(StateHasChanged);
        });

        await _hubConnection.StartAsync();

    }

    public bool IsConnected =>
        _hubConnection?.State == HubConnectionState.Connected;

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.DisposeAsync();
        }
    }

    private string GetColorFromValue(ushort value)
    {
        // Załóżmy, że maksymalna wartość to 4000
        double ratio = Math.Clamp(value / (double)4000, 0, 1);
        int scaledRatio = (int)(ratio * 255);

        int r, g, b;

        if (ratio <= 0.25)
        {
            // Pierwsza ćwiartka: od czerwonego do żółtego
            r = 255;
            g = scaledRatio * 4; // Zwiększanie zielonego
            b = 0;
        }
        else if (ratio <= 0.5)
        {
            // Druga ćwiartka: od żółtego do zielonego
            r = 255 - ((scaledRatio - 64) * 4); // Redukcja czerwonego
            g = 255; // Zielony jest maksymalny
            b = 0;
        }
        else if (ratio <= 0.75)
        {
            // Trzecia ćwiartka: od zielonego do niebieskiego
            r = 0; // Czerwony jest minimalny
            g = 255 - ((scaledRatio - 128) * 4); // Redukcja zielonego
            b = (scaledRatio - 128) * 4; // Zwiększanie niebieskiego
        }
        else
        {
            // Czwarta ćwiartka: od niebieskiego do fioletowego
            r = (scaledRatio - 192) * 4; // Zwiększanie czerwonego
            g = 0; // Zielony jest minimalny
            b = 255; // Niebieski jest maksymalny
        }

        return $"rgb({Math.Clamp(r, 0, 255)}, {Math.Clamp(g, 0, 255)}, {Math.Clamp(b, 0, 255)})";
    }

    //================================================================================================================================
    //DEBUG FUNCTIONS

    private ushort[] GenerateTestData(int resolution)
    {
        var random = new Random();
        ushort[] data = new ushort[resolution * resolution];

        for (int i = 0; i < data.Length; i++)
        {
            data[i] = (ushort)random.Next(0, 4000);
        }

        return data;
    }

    private ushort[] GenerateTestDataAscend(int resolution)
    {
        ushort[] data = new ushort[resolution * resolution];

        int index = 0;

        for (int i = 0; i < resolution; i++)
        {
            for (int j = 0; j < resolution; j++)
            {
                data[index] = (ushort)(i * 125 + j);
                index++;
            }
        }

        return data;
    }

    //================================================================================================================================


}
