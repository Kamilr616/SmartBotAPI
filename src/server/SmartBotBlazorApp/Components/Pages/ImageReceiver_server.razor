@page "/image-receiver-server"
@rendermode InteractiveServer
@inject NavigationManager Navigation
@implements IAsyncDisposable

@using System.Numerics
@using System.Text.Json
@using RobotMovementInput


<PageTitle>Live View Image Server</PageTitle>

<div class="container">
    <!-- Depth Image on the Left Side -->
    <table @ref="_keyobardInputHandler.keyboardInputRef" tabindex="0" @onkeydown="HandleKeyDown">
        <div class="left-section">
            @if (_imageSrc == null)
            {
                <p><em>Waiting for image ...</em></p>
                <div class="spinner-wrapper">
                    <div class="spinner-border" role="status"></div>
                </div>
            }
            else
            {
                <img src="@_imageSrc" alt="Depth Image" width="640" height="640" />
            <thead>
                <tr>
                    <th>Pressed Key</th>
                    <th>Counter</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>@_keyobardInputHandler.pressedKey</td>
                    <td>@_keyobardInputHandler.counter</td>
                </tr>
            </tbody>
            }
</div>
    </table>

<!-- Info Section on the Right Side -->
<div class="right-section">
    <!-- Connection Status Section -->
    <div class="status-section">
        <h5>SignalR Hub</h5>
            @if (IsConnected)
            {
            <p style="color: green; font-weight: bold;">Connected</p>
            }
            else
            {
            <p style="color: red; font-weight: bold;">Disconnected</p>
            }
    </div>

    <!-- Data Status Section -->
        @if (_avgDistance == null || _measurements == null || _hubUser == null)
        {
        <p><em>Waiting for data ...</em></p>
        <div class="spinner-border" role="status"></div>
        }
        else
        {
        <div>
            <!-- User and Average Distance Section -->
            <div class="status-section">
                <div class="data-item">
                    <h5>User</h5>
                    <p>@_hubUser</p>
                </div>
                <div class="data-item">
                    <h5>Average Distance</h5>
                    <p>@_avgDistance mm</p>
                </div>
            </div>

            <!-- Data Section -->
            <div class="data-section">
                <div class="data-item">
                    <h5>Acceleration X</h5>
                    <p>@_measurements[0]</p>
                </div>
                <div class="data-item">
                    <h5>Acceleration Y</h5>
                    <p>@_measurements[1]</p>
                </div>
                <div class="data-item">
                    <h5>Acceleration Z</h5>
                    <p>@_measurements[2]</p>
                </div>
                <div class="data-item">
                    <h5>Rotation X</h5>
                    <p>@_measurements[3]</p>
                </div>
                <div class="data-item">
                    <h5>Rotation Y</h5>
                    <p>@_measurements[4]</p>
                </div>
                <div class="data-item">
                    <h5>Rotation Z</h5>
                    <p>@_measurements[5]</p>
                </div>
                <div class="data-item">
                    <h5>Temperature</h5>
                    <p>@_measurements[6] C</p>
                </div>
            </div>
        </div>
        }
</div>

<div class="joystick-container">
    <!-- Joystick Section -->
    <div id="joystickContainer" @onpointerdown="OnPointerDown" @onpointermove="OnPointerMove" @onpointerup="OnPointerUp" @onpointercancel="OnPointerUp">
        <div id="joystickKnob" style="left: @(_joystickHandler.KnobPosX - 25)px; top: @(_joystickHandler.KnobPosY - @joystickRadius)px;"></div>
    </div>

    <!-- Data Section -->
    <table>
        <tbody>
            <tr>
                <td>@_joystickHandler.joystickDirection</td>
                <td>@_joystickHandler.Counter</td>
            </tr>
        </tbody>
    </table>
</div>


</div>


@code {
    private static int joystickCenterX = 50;
    private static int joystickCenterY = 50;
    private static int joystickRadius = 25;
    private JoystickInputHandler _joystickHandler = new JoystickInputHandler(joystickCenterX,joystickCenterY,joystickRadius);
    private CancellationTokenSource? _joystickCancellationTokenSource;


    private async Task StartJoystickMessageLoop()
    {
        _joystickCancellationTokenSource?.Cancel();
        _joystickCancellationTokenSource = new CancellationTokenSource();
        var token = _joystickCancellationTokenSource.Token;

        try
        {
            while (!token.IsCancellationRequested)
            {
                if(_joystickHandler.validInput)
                {
                    sendInputToRobot(new RobotCommand(_joystickHandler.robotDir).nextDirection.ToString());
                    _joystickHandler.increaseCounter();
                }

                InvokeAsync(StateHasChanged);
                await Task.Delay(10, token);
            }
        }
        catch (TaskCanceledException)
        {
            _joystickHandler.resetCounter();

        }
    }


    private void StopJoystickMessageLoop()
    {
        _joystickCancellationTokenSource?.Cancel();
    }

    //passthorugh, for implemeneting inner logic later on
    //TODO: refactor later
    private void OnPointerDown(PointerEventArgs e)
    {
        _joystickHandler.OnPointerDown(e.ClientX, e.ClientY);
        _ = StartJoystickMessageLoop();
    }

    private void OnPointerMove(PointerEventArgs e)
    {
        _joystickHandler.OnPointerMove(e.ClientX, e.ClientY);
    }

    private void OnPointerUp(PointerEventArgs e)
    {
        _joystickHandler.OnPointerUp();
        StopJoystickMessageLoop();
    }


    //--------------------------------
    private HubConnection? _hubConnection;
    private ushort? _avgDistance;
    private string? _hubUser;
    private double[]? _measurements;
    private string? _imageSrc;


    //keyboardInputs
    //--------------------------------------------------------------------------------------------------
    //keyboardInputs
    private keyboardInputHandler _keyobardInputHandler = new keyboardInputHandler();
    private ROBOT_DIRECITON previousDir = ROBOT_DIRECITON.STOP;



    private void HandleKeyDown(KeyboardEventArgs e)
    {

        _keyobardInputHandler.onKeyDown(e);
        _keyobardInputHandler.amIResetingCounter(previousDir != _keyobardInputHandler.robotDir);
        previousDir = _keyobardInputHandler.robotDir;


        if (_keyobardInputHandler.validInput)
        {
            sendInputToRobot(new RobotCommand(_keyobardInputHandler.robotDir).nextDirection.ToString());
        }
    }



    private async void sendInputToRobot(string message)
    {
        if(_hubConnection is not null)
        {
            await _hubConnection.SendAsync("SendMessage", "User", message);
        }
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await _keyobardInputHandler.keyboardInputRef.FocusAsync();
        }
    }

    //---------------------------------------------------------------------------------------

    protected override async Task OnInitializedAsync()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/signalhub"))
            .Build();

        _hubConnection.On<string, double[], string, ushort>("ReceiveBase64Frame", (user, measurements, base64Image, avgDistance) =>
        {
            _hubUser = user;
            _measurements = measurements;
            _avgDistance = avgDistance;

            _imageSrc = $"data:image/png;base64,{base64Image}";

            InvokeAsync(StateHasChanged); 
        });

        await _hubConnection.StartAsync();
    }

    public bool IsConnected =>
        _hubConnection?.State == HubConnectionState.Connected;

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.DisposeAsync();
        }
    }



}
