@page "/image-receiver-server"
@rendermode InteractiveServer
@inject NavigationManager Navigation
@implements IAsyncDisposable
@attribute [Authorize]
@using RobotMovementInput

<PageTitle>Live View Image Server</PageTitle>

<div class="container">
    <!-- Depth Image on the Left Side -->
    <table @ref="_keyobardInputHandler.keyboardInputRef" tabindex="0" @onkeydown="HandleKeyDown" @onkeyup="stopInputToRobot" >
        <div class="left-section">
            @if (_imageSrc == null)
            {
                <p><em>Waiting for image</em></p>
                <div class="spinner-wrapper">
                    <div class="spinner-border" role="status"/>
                </div>
            }
            else
            {
                <img src="@_imageSrc" alt="Depth Image" width="640" height="640" />
            <thead>
                <tr>
                    <th>
                        Pressed Key
                    </th>
                    <th>
                        Counter
                    </th>
                    <th>
                        <div class="joystick-container">
                            <!-- Joystick Section -->
                            <div id="joystickContainer" @onpointerdown="OnPointerDown" @onpointermove="OnPointerMove" @onpointerup="OnPointerUp" @onpointercancel="OnPointerUp">
                                <div id="joystickKnob" style="left: @(_joystickHandler.KnobPosX - 25)px; top: @(_joystickHandler.KnobPosY - @joystickRadius)px;"></div>
                            </div>
                        </div>
                    </th>
                    <th>
                        Joystick Counter
                    </th>
                    <th>
                        StopRobot
                    </th>
                </tr>

            </thead>

            <tbody>
                <tr>
                    <td>
                            @_keyobardInputHandler.pressedKey
                    </td>
                    <td>
                            @_keyobardInputHandler.counter

                    </td>
                    <td>@_joystickHandler.joystickDirection</td>
                    <td>@_joystickHandler.Counter</td>
                    <td>@_didIStoppedRobot</td>

                </tr>
            </tbody>

            }
</div>
    </table>

<!-- Info Section on the Right Side -->
<div class="right-section">
    <!-- Connection Status Section -->
    <div class="status-section">
        <h5>SignalR Hub</h5>
            @if (IsConnected)
            {
            <p style="color: green; font-weight: bold;">Connected</p>
            }
            else
            {
            <p style="color: red; font-weight: bold;">Disconnected</p>
            }
    </div>

    <!-- Data Status Section -->
        @if (_avgDistance == null || _measurements == null || _hubUser == null)
        {
        <p><em>Waiting for data</em></p>
        <div class="spinner-border" role="status"/>
        }
        else
        {
        <div>
            <!-- User and Average Distance Section -->
            <div class="status-section">
                <div class="data-item">
                    <h5>User</h5>
                    <p>@_hubUser</p>
                </div>
                <div class="data-item">
                    <h5>Average Distance</h5>
                    <p>@_avgDistance mm</p>
                </div>
            </div>

            <!-- Data Section -->
            <div class="data-section">
                <div class="data-item">
                    <h5>Acceleration X</h5>
                    <p>@_measurements[0]</p>
                </div>
                <div class="data-item">
                    <h5>Acceleration Y</h5>
                    <p>@_measurements[1]</p>
                </div>
                <div class="data-item">
                    <h5>Acceleration Z</h5>
                    <p>@_measurements[2]</p>
                </div>
                <div class="data-item">
                    <h5>Rotation X</h5>
                    <p>@_measurements[3]</p>
                </div>
                <div class="data-item">
                    <h5>Rotation Y</h5>
                    <p>@_measurements[4]</p>
                </div>
                <div class="data-item">
                    <h5>Rotation Z</h5>
                    <p>@_measurements[5]</p>
                </div>
                <div class="data-item">
                    <h5>Temperature</h5>
                    <p>@_measurements[6] C</p>
                </div>
            </div>
        </div>
        }
</div>
</div>



@code {
    private static int joystickCenterX = 50;
    private static int joystickCenterY = 50;
    private static int joystickRadius = 25;
    private JoystickInputHandler _joystickHandler = new JoystickInputHandler(joystickCenterX, joystickCenterY, joystickRadius);
    private CancellationTokenSource? _joystickCancellationTokenSource;

    private HubConnection? _hubConnection;
    private ushort? _avgDistance;
    private string? _hubUser;
    private double[]? _measurements;
    private string? _imageSrc;

    private keyboardInputHandler _keyobardInputHandler = new keyboardInputHandler();
    private ROBOT_DIRECITON previousDir = ROBOT_DIRECITON.STOP;

    private int _LeftEngineValue = 0;
    private int _RightEngineValue = 0;


    //Throttle

    private static DateTime _lastSaveTimeRobotInput = DateTime.MinValue;
    private static readonly TimeSpan ThrottleDurationSendRobotInput = TimeSpan.FromSeconds(1);
    
    //TODO, przerobic na stateMachine
    //-----------------
    //szybkihack
    private bool _didIStoppedRobot = false;

    private async Task StartJoystickMessageLoop()
    {
        _joystickCancellationTokenSource?.Cancel();
        _joystickCancellationTokenSource = new CancellationTokenSource();
        var token = _joystickCancellationTokenSource.Token;

        try
        {
            while (!token.IsCancellationRequested)
            {
                if (_joystickHandler.validInput)
                {
                    //DEPRECIATED
                    // sendInputToRobot(new RobotCommand(_joystickHandler.robotDir).nextDirection.ToString());
                    sendInputToRobot(_joystickHandler.GetRobotEngineValues());
                    _joystickHandler.increaseCounter();
                }

                await InvokeAsync(StateHasChanged);
                await Task.Delay(10, token);
            }
        }
        catch (TaskCanceledException)
        {
            _joystickHandler.resetCounter();

        }
    }

    private void StopJoystickMessageLoop()
    {
        _joystickCancellationTokenSource?.Cancel();
    }

    // TODO: refactor, passthorugh, for implemeneting inner logic
    private void OnPointerDown(PointerEventArgs e)
    {
        _joystickHandler.OnPointerDown(e.ClientX, e.ClientY);
        _LeftEngineValue = _joystickHandler.GetRobotEngineValues().Item1;
        _RightEngineValue = _joystickHandler.GetRobotEngineValues().Item2;

        _ = StartJoystickMessageLoop();
    }

    private void OnPointerMove(PointerEventArgs e)
    {
        _joystickHandler.OnPointerMove(e.ClientX, e.ClientY);
    }

    private async void OnPointerUp(PointerEventArgs e)
    {
        _joystickHandler.OnPointerUp();
        await stopInputToRobot();

        StopJoystickMessageLoop();
    }


    private async void sendInputToRobot((int, int) engineValues)
    {
        if (_didIStoppedRobot)
        {
            return;
        }
        _didIStoppedRobot = false;

        if (_hubConnection is not null)
        {

            var currentTime = DateTime.Now;

            if ((currentTime - _lastSaveTimeRobotInput) <= ThrottleDurationSendRobotInput)
            {
                return;
            }
            _didIStoppedRobot = false;
            _lastSaveTimeRobotInput = currentTime;
            await _hubConnection.SendAsync("SendMovementCommand", "API", engineValues.Item1, engineValues.Item2);
        }
    }

    //szybki hack, kiedys sie zrobi ladniej
    private async Task stopInputToRobot()
    {
        _LeftEngineValue = 0;
        _RightEngineValue = 0;
        _didIStoppedRobot = true;

        if (_hubConnection is not null)
        {
            var currentTime = DateTime.Now;
            _lastSaveTimeRobotInput = currentTime;

            _didIStoppedRobot = true;
            await _hubConnection.SendAsync("SendMovementCommand", "API", 0, 0);
        }
        await Task.Delay(1000);
        _didIStoppedRobot = false;


    }


    private void HandleKeyDown(KeyboardEventArgs e)
    {

        _keyobardInputHandler.onKeyDown(e);
        _keyobardInputHandler.amIResetingCounter(previousDir != _keyobardInputHandler.robotDir);
        previousDir = _keyobardInputHandler.robotDir;

        _LeftEngineValue = _keyobardInputHandler.GetRobotEngineValues().Item1;
        _RightEngineValue = _keyobardInputHandler.GetRobotEngineValues().Item2;

        if (_keyobardInputHandler.validInput)
        {
            //Depreciated
            // sendInputToRobot(new RobotCommand(_keyobardInputHandler.robotDir).nextDirection.ToString());
            var currentTime = DateTime.Now;

            if ((currentTime - _lastSaveTimeRobotInput) <= ThrottleDurationSendRobotInput)
            {
                return;
            }
            
            sendInputToRobot(_keyobardInputHandler.GetRobotEngineValues());
        }
    }

    // private void HandleKeyUP(KeyboardEventArgs e)
    // {

    //     _keyobardInputHandler.onKeyUP(e);
    //     _keyobardInputHandler.amIResetingCounter(true);

    //     _LeftEngineValue = _keyobardInputHandler.GetRobotEngineValues().Item1;
    //     _RightEngineValue = _keyobardInputHandler.GetRobotEngineValues().Item2;

    //     if (_keyobardInputHandler.validInput)
    //     {
    //         sendInputToRobot(_keyobardInputHandler.GetRobotEngineValues());
    //     }
    // }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await _keyobardInputHandler.keyboardInputRef.FocusAsync();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        
        // DEBUG nie dziala
//--------------------------------------------------------------------------------------------------------
        // _measurements = debugFunctions.GenerateTestDataAscendDouble(32);
        // _avgDistance = 10;
        // _hubUser = "TEST_DATA";
        // await Task.CompletedTask; 
        
//--------------------------------------------------------------------------------------------------------


        _hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/signalhub"))
            .Build();

        _hubConnection.On<string, double[], string, ushort>("ReceiveBase64Frame", (user, measurements, base64Image, avgDistance) =>
        {
            _hubUser = user;
            _measurements = measurements;
            _avgDistance = avgDistance;

            _imageSrc = $"data:image/png;base64,{base64Image}";

            InvokeAsync(StateHasChanged);
        });

        await _hubConnection.StartAsync();
    }

    public bool IsConnected =>
        _hubConnection?.State == HubConnectionState.Connected;


    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.DisposeAsync();
        }
    }
}
