@page "/image-receiver-server"
@rendermode InteractiveServer
@inject NavigationManager Navigation
@implements IAsyncDisposable

@using System.Numerics
@using System.Text.Json

<PageTitle>Live View Image Server</PageTitle>

<div class="container">
    <!-- Depth Image on the Left Side -->
    <table @ref="keyboardInputRef" tabindex="0" @onkeydown="HandleKeyDown">
        <div class="left-section">
            @if (_imageSrc == null)
            {
                <p><em>Waiting for image ...</em></p>
                <div class="spinner-wrapper">
                    <div class="spinner-border" role="status"></div>
                </div>
            }
            else
            {
                <img src="@_imageSrc" alt="Depth Image" width="640" height="640" />
            <thead>
                <tr>
                    <th>Pressed Key</th>
                    <th>Counter</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>@pressedKey</td>
                    <td>@counter</td>
                </tr>
            </tbody>
            }
</div>
    </table>

<!-- Info Section on the Right Side -->
<div class="right-section">
    <!-- Connection Status Section -->
    <div class="status-section">
        <h5>SignalR Hub</h5>
            @if (IsConnected)
            {
            <p style="color: green; font-weight: bold;">Connected</p>
            }
            else
            {
            <p style="color: red; font-weight: bold;">Disconnected</p>
            }
    </div>

    <!-- Data Status Section -->
        @if (_avgDistance == null || _measurements == null || _hubUser == null)
        {
        <p><em>Waiting for data ...</em></p>
        <div class="spinner-border" role="status"></div>
        }
        else
        {
        <div>
            <!-- User and Average Distance Section -->
            <div class="status-section">
                <div class="data-item">
                    <h5>User</h5>
                    <p>@_hubUser</p>
                </div>
                <div class="data-item">
                    <h5>Average Distance</h5>
                    <p>@_avgDistance mm</p>
                </div>
            </div>

            <!-- Data Section -->
            <div class="data-section">
                <div class="data-item">
                    <h5>Acceleration X</h5>
                    <p>@_measurements[0]</p>
                </div>
                <div class="data-item">
                    <h5>Acceleration Y</h5>
                    <p>@_measurements[1]</p>
                </div>
                <div class="data-item">
                    <h5>Acceleration Z</h5>
                    <p>@_measurements[2]</p>
                </div>
                <div class="data-item">
                    <h5>Rotation X</h5>
                    <p>@_measurements[3]</p>
                </div>
                <div class="data-item">
                    <h5>Rotation Y</h5>
                    <p>@_measurements[4]</p>
                </div>
                <div class="data-item">
                    <h5>Rotation Z</h5>
                    <p>@_measurements[5]</p>
                </div>
                <div class="data-item">
                    <h5>Temperature</h5>
                    <p>@_measurements[6] C</p>
                </div>
            </div>
        </div>
        }
</div>

<div class="joystick-container">
    <!-- Joystick Section -->
    <div id="joystickContainer" @onpointerdown="OnPointerDown" @onpointermove="OnPointerMove" @onpointerup="OnPointerUp" @onpointercancel="OnPointerUp">
        <div id="joystickKnob" style="left: @(knobPosX - 25)px; top: @(knobPosY - 25)px;"></div>
    </div>

    <!-- Data Section -->
    <table>
        <tbody>
            <tr>
                <td>@joyDir</td>
                <td>@joycounter</td>
            </tr>
        </tbody>
    </table>
</div>


</div>


@code {
    private double joystickCenterX = 50;
    private double joystickCenterY = 50;
    private double knobPosX = 50;       
    private double knobPosY = 50;

    private bool isTouching = false;
    private double touchStartX;
    private double touchStartY;

    private string? joyDir;
    private int joycounter = 0;

    private void OnPointerDown(PointerEventArgs e)
    {
        isTouching = true;
        touchStartX = e.ClientX;
        touchStartY = e.ClientY;

    }

    private void OnPointerMove(PointerEventArgs e)
    {
        if (isTouching)
        {
            double deltaX = e.ClientX - touchStartX;
            double deltaY = e.ClientY - touchStartY;
            //distance from center
            double distance = Math.Sqrt(Math.Pow(deltaX, 2) + Math.Pow(deltaY, 2));

            // Limit the distance to the radius of the joystick container
            double radius = 25; // maximum distance from center
            double newX = joystickCenterX + deltaX;
            double newY = joystickCenterY + deltaY;

            if (distance > radius)
            {
                newX = knobPosX;
                newY = knobPosY;
            }

            knobPosX = newX;
            knobPosY = newY;
            joycounter++;
            joyDir = GetJoystickDirection(knobPosX, knobPosY);

        }
    }

    private void OnPointerUp(PointerEventArgs e)
    {
        isTouching = false;
        knobPosX = joystickCenterX;
        knobPosY = joystickCenterY;
    }


    public string GetJoystickDirection(double knobPosX, double knobPosY)
    {
        // Joystick container dimensions
        double containerWidth = 100;
        double containerHeight = 100;

        // Calculate the center of the joystick container
        double centerX = containerWidth / 2;
        double centerY = containerHeight / 2;

        // Calculate the distance of the knob from the center
        double deltaX = knobPosX - centerX;
        double deltaY = knobPosY - centerY;

        // Define the threshold for considering the knob to be in the "middle" area
        double threshold = 5;

        // Determine the direction based on the deltas
        if (Math.Abs(deltaX) > Math.Abs(deltaY))  // Horizontal
        {
            if (deltaX > threshold)
            {
                return "Right";
            }
            else if (deltaX < -threshold)
            {
                return "Left";
            }
        }
        else  // Vertical
        {
            if (deltaY > threshold)
            {
                return "Down";
            }
            else if (deltaY < -threshold)
            {
                return "Up";
            }
        }
        return "Center";
    }


    //--------------------------------
    private HubConnection? _hubConnection;
    private ushort? _avgDistance;
    private string? _hubUser;
    private double[]? _measurements;
    private string? _imageSrc;


    //keyboardInputs
    //--------------------------------------------------------------------------------------------------
    private ElementReference keyboardInputRef;
    private string? pressedKey;
    private int counter = 0;
    private int previousDir = -1;



    //to jest przykladowy format jsona ktorego wyslemy robotowi
    public struct robotCommand
    {
        public string type { get; set; }
        public string target { get; set; }
        public int nextDirection { get; set; }

        public robotCommand(int nextDir)
        {
            type = "input";
            target = "movementController";
            nextDirection = nextDir;
        }

        public string toJson()
        {
            return System.Text.Json.JsonSerializer.Serialize(this);
        }

    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        keyboardInputHandler tmp = new keyboardInputHandler(e);
        pressedKey = tmp.keyName;
        if (previousDir != tmp.robotDir)
            counter = 0;


        if (tmp.validInput)
        {
            sendInputToRobot(new robotCommand(tmp.robotDir).toJson());
            counter++;


            previousDir = tmp.robotDir;
        }
    }


    private void sendInputToRobot(string jsonCommand)
    {
        //tutaj wydmuszka, funkcja dostaje jsona z komenda ktora trzeba wyslac robotowi
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await keyboardInputRef.FocusAsync();
        }
    }

    //---------------------------------------------------------------------------------------

    protected override async Task OnInitializedAsync()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/signalhub"))
            .Build();

        _hubConnection.On<string, double[], string, ushort>("ReceiveBase64Frame", (user, measurements, base64Image, avgDistance) =>
        {
            _hubUser = user;
            _measurements = measurements;
            _avgDistance = avgDistance;

            _imageSrc = $"data:image/png;base64,{base64Image}";

            InvokeAsync(StateHasChanged); 
        });

        await _hubConnection.StartAsync();
    }

    public bool IsConnected =>
        _hubConnection?.State == HubConnectionState.Connected;

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.DisposeAsync();
        }
    }



}
